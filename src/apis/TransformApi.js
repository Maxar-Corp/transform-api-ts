"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * Transform API
 * TODO
 *
 * The version of the OpenAPI document: 1.0
 * Contact: someone@maxar.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultApi = void 0;
const runtime = __importStar(require("../runtime"));
const index_1 = require("../models/index");
/**
 *
 */
class DefaultApi extends runtime.BaseAPI {
    /**
     * Get the results from executing and evaluating a script via a script id, parameters, and an function name.
     * Execute and evaluate a script
     */
    async evalScriptRaw(requestParameters, initOverrides) {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling evalScript.');
        }
        if (requestParameters._function === null || requestParameters._function === undefined) {
            throw new runtime.RequiredError('_function', 'Required parameter requestParameters._function was null or undefined when calling evalScript.');
        }
        const queryParameters = {};
        if (requestParameters._function !== undefined) {
            queryParameters['function'] = requestParameters._function;
        }
        if (requestParameters.p) {
            queryParameters['p'] = requestParameters.p;
        }
        const headerParameters = {};
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth", []);
        }
        const response = await this.request({
            path: `/v1/ipe/{id}/eval`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => (0, index_1.EvalScriptResponseFromJSON)(jsonValue));
    }
    /**
     * Get the results from executing and evaluating a script via a script id, parameters, and an function name.
     * Execute and evaluate a script
     */
    async evalScript(requestParameters, initOverrides) {
        const response = await this.evalScriptRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Get a list of all domain functions available to IPEScript.
     * Get a list of all domain function.
     */
    async getFunctionListRaw(initOverrides) {
        const queryParameters = {};
        const headerParameters = {};
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth", []);
        }
        const response = await this.request({
            path: `/v1/function`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(index_1.FunctionDescriptorFromJSON));
    }
    /**
     * Get a list of all domain functions available to IPEScript.
     * Get a list of all domain function.
     */
    async getFunctionList(initOverrides) {
        const response = await this.getFunctionListRaw(initOverrides);
        return await response.value();
    }
    /**
     * Get a script given a script id.
     */
    async getScriptRaw(requestParameters, initOverrides) {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling getScript.');
        }
        const queryParameters = {};
        const headerParameters = {};
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth", []);
        }
        const response = await this.request({
            path: `/v1/ipe/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.VoidApiResponse(response);
    }
    /**
     * Get a script given a script id.
     */
    async getScript(requestParameters, initOverrides) {
        await this.getScriptRaw(requestParameters, initOverrides);
    }
    /**
     * Support virtual image as GeoTIFF given a script id, function name, script parameters (provided as url query parameters), and a valid byte range. The entire dataset represented by the script, function and parameters is presented as a geotiff and this method allows a user to read a portion of the virtual GeoTIFF. See [Byte Serving](https://en.wikipedia.org/wiki/Byte_serving).
     * Get a byte range from a virtual GeoTIFF from a script function
     */
    async getScriptGeotiffRaw(requestParameters, initOverrides) {
        if (requestParameters.range === null || requestParameters.range === undefined) {
            throw new runtime.RequiredError('range', 'Required parameter requestParameters.range was null or undefined when calling getScriptGeotiff.');
        }
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling getScriptGeotiff.');
        }
        if (requestParameters._function === null || requestParameters._function === undefined) {
            throw new runtime.RequiredError('_function', 'Required parameter requestParameters._function was null or undefined when calling getScriptGeotiff.');
        }
        const queryParameters = {};
        if (requestParameters._function !== undefined) {
            queryParameters['function'] = requestParameters._function;
        }
        if (requestParameters.prefetch !== undefined) {
            queryParameters['prefetch'] = requestParameters.prefetch;
        }
        if (requestParameters.p) {
            queryParameters['p'] = requestParameters.p;
        }
        const headerParameters = {};
        if (requestParameters.range !== undefined && requestParameters.range !== null) {
            headerParameters['range'] = String(requestParameters.range);
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth", []);
        }
        const response = await this.request({
            path: `/v1/ipe/{id}/geotiff`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.BlobApiResponse(response);
    }
    /**
     * Support virtual image as GeoTIFF given a script id, function name, script parameters (provided as url query parameters), and a valid byte range. The entire dataset represented by the script, function and parameters is presented as a geotiff and this method allows a user to read a portion of the virtual GeoTIFF. See [Byte Serving](https://en.wikipedia.org/wiki/Byte_serving).
     * Get a byte range from a virtual GeoTIFF from a script function
     */
    async getScriptGeotiff(requestParameters, initOverrides) {
        const response = await this.getScriptGeotiffRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Get metadata about an image given a script id, parameters, and an function name.
     * Get image metadata
     */
    async getScriptMetadataRaw(requestParameters, initOverrides) {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling getScriptMetadata.');
        }
        if (requestParameters._function === null || requestParameters._function === undefined) {
            throw new runtime.RequiredError('_function', 'Required parameter requestParameters._function was null or undefined when calling getScriptMetadata.');
        }
        const queryParameters = {};
        if (requestParameters._function !== undefined) {
            queryParameters['function'] = requestParameters._function;
        }
        if (requestParameters.p) {
            queryParameters['p'] = requestParameters.p;
        }
        if (requestParameters.key !== undefined) {
            queryParameters['key'] = requestParameters.key;
        }
        const headerParameters = {};
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth", []);
        }
        const response = await this.request({
            path: `/v1/ipe/{id}/metadata`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => (0, index_1.UnifiedMetadataFromJSON)(jsonValue));
    }
    /**
     * Get metadata about an image given a script id, parameters, and an function name.
     * Get image metadata
     */
    async getScriptMetadata(requestParameters, initOverrides) {
        const response = await this.getScriptMetadataRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Store the script. The generated unique \"id\" is returned. Make sure to save the \"id\" returned for the resulting script to use when referencing this script. Scripts are NOT editable and any changes, when posted, will cause a new script \"id\" to be generated.
     * Store script
     */
    async storeScriptRaw(requestParameters, initOverrides) {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body', 'Required parameter requestParameters.body was null or undefined when calling storeScript.');
        }
        const queryParameters = {};
        const headerParameters = {};
        headerParameters['Content-Type'] = 'text/plain';
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth", []);
        }
        const response = await this.request({
            path: `/v1/ipe`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => (0, index_1.StoreScriptResponseFromJSON)(jsonValue));
    }
    /**
     * Store the script. The generated unique \"id\" is returned. Make sure to save the \"id\" returned for the resulting script to use when referencing this script. Scripts are NOT editable and any changes, when posted, will cause a new script \"id\" to be generated.
     * Store script
     */
    async storeScript(requestParameters, initOverrides) {
        const response = await this.storeScriptRaw(requestParameters, initOverrides);
        return await response.value();
    }
}
exports.DefaultApi = DefaultApi;
//# sourceMappingURL=TransformApi.js.map